import time, urandom
from utils import get_stdin_byte_or_button_press
from machine import Timer, Pin
from graphics import OLED_WIDTH, OLED_HEIGHT

FIELD_WIDTH = 10
FIELD_HEIGHT = 20
BLOCK_SIZE = 6

# https://github.com/micropython/micropython/blob/668a7bd28a49980b239fd7666684885382526988/extmod/font_petme128_8x8.h
font_petme128_8x8 = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # 32=
    0x00, 0x00, 0x00, 0x4f, 0x4f, 0x00, 0x00, 0x00, # 33=!
    0x00, 0x07, 0x07, 0x00, 0x00, 0x07, 0x07, 0x00, # 34="
    0x14, 0x7f, 0x7f, 0x14, 0x14, 0x7f, 0x7f, 0x14, # 35=#
    0x00, 0x24, 0x2e, 0x6b, 0x6b, 0x3a, 0x12, 0x00, # 36=$
    0x00, 0x63, 0x33, 0x18, 0x0c, 0x66, 0x63, 0x00, # 37=%
    0x00, 0x32, 0x7f, 0x4d, 0x4d, 0x77, 0x72, 0x50, # 38=&
    0x00, 0x00, 0x00, 0x04, 0x06, 0x03, 0x01, 0x00, # 39='
    0x00, 0x00, 0x1c, 0x3e, 0x63, 0x41, 0x00, 0x00, # 40=(
    0x00, 0x00, 0x41, 0x63, 0x3e, 0x1c, 0x00, 0x00, # 41=)
    0x08, 0x2a, 0x3e, 0x1c, 0x1c, 0x3e, 0x2a, 0x08, # 42=*
    0x00, 0x08, 0x08, 0x3e, 0x3e, 0x08, 0x08, 0x00, # 43=+
    0x00, 0x00, 0x80, 0xe0, 0x60, 0x00, 0x00, 0x00, # 44=,
    0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, # 45=-
    0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, # 46=.
    0x00, 0x40, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, # 47=/
    0x00, 0x3e, 0x7f, 0x49, 0x45, 0x7f, 0x3e, 0x00, # 48=0
    0x00, 0x40, 0x44, 0x7f, 0x7f, 0x40, 0x40, 0x00, # 49=1
    0x00, 0x62, 0x73, 0x51, 0x49, 0x4f, 0x46, 0x00, # 50=2
    0x00, 0x22, 0x63, 0x49, 0x49, 0x7f, 0x36, 0x00, # 51=3
    0x00, 0x18, 0x18, 0x14, 0x16, 0x7f, 0x7f, 0x10, # 52=4
    0x00, 0x27, 0x67, 0x45, 0x45, 0x7d, 0x39, 0x00, # 53=5
    0x00, 0x3e, 0x7f, 0x49, 0x49, 0x7b, 0x32, 0x00, # 54=6
    0x00, 0x03, 0x03, 0x79, 0x7d, 0x07, 0x03, 0x00, # 55=7
    0x00, 0x36, 0x7f, 0x49, 0x49, 0x7f, 0x36, 0x00, # 56=8
    0x00, 0x26, 0x6f, 0x49, 0x49, 0x7f, 0x3e, 0x00, # 57=9
    0x00, 0x00, 0x00, 0x24, 0x24, 0x00, 0x00, 0x00, # 58=:
    0x00, 0x00, 0x80, 0xe4, 0x64, 0x00, 0x00, 0x00, # 59=;
    0x00, 0x08, 0x1c, 0x36, 0x63, 0x41, 0x41, 0x00, # 60=<
    0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, # 61==
    0x00, 0x41, 0x41, 0x63, 0x36, 0x1c, 0x08, 0x00, # 62=>
    0x00, 0x02, 0x03, 0x51, 0x59, 0x0f, 0x06, 0x00, # 63=?
    0x00, 0x3e, 0x7f, 0x41, 0x4d, 0x4f, 0x2e, 0x00, # 64=@
    0x00, 0x7c, 0x7e, 0x0b, 0x0b, 0x7e, 0x7c, 0x00, # 65=A
    0x00, 0x7f, 0x7f, 0x49, 0x49, 0x7f, 0x36, 0x00, # 66=B
    0x00, 0x3e, 0x7f, 0x41, 0x41, 0x63, 0x22, 0x00, # 67=C
    0x00, 0x7f, 0x7f, 0x41, 0x63, 0x3e, 0x1c, 0x00, # 68=D
    0x00, 0x7f, 0x7f, 0x49, 0x49, 0x41, 0x41, 0x00, # 69=E
    0x00, 0x7f, 0x7f, 0x09, 0x09, 0x01, 0x01, 0x00, # 70=F
    0x00, 0x3e, 0x7f, 0x41, 0x49, 0x7b, 0x3a, 0x00, # 71=G
    0x00, 0x7f, 0x7f, 0x08, 0x08, 0x7f, 0x7f, 0x00, # 72=H
    0x00, 0x00, 0x41, 0x7f, 0x7f, 0x41, 0x00, 0x00, # 73=I
    0x00, 0x20, 0x60, 0x41, 0x7f, 0x3f, 0x01, 0x00, # 74=J
    0x00, 0x7f, 0x7f, 0x1c, 0x36, 0x63, 0x41, 0x00, # 75=K
    0x00, 0x7f, 0x7f, 0x40, 0x40, 0x40, 0x40, 0x00, # 76=L
    0x00, 0x7f, 0x7f, 0x06, 0x0c, 0x06, 0x7f, 0x7f, # 77=M
    0x00, 0x7f, 0x7f, 0x0e, 0x1c, 0x7f, 0x7f, 0x00, # 78=N
    0x00, 0x3e, 0x7f, 0x41, 0x41, 0x7f, 0x3e, 0x00, # 79=O
    0x00, 0x7f, 0x7f, 0x09, 0x09, 0x0f, 0x06, 0x00, # 80=P
    0x00, 0x1e, 0x3f, 0x21, 0x61, 0x7f, 0x5e, 0x00, # 81=Q
    0x00, 0x7f, 0x7f, 0x19, 0x39, 0x6f, 0x46, 0x00, # 82=R
    0x00, 0x26, 0x6f, 0x49, 0x49, 0x7b, 0x32, 0x00, # 83=S
    0x00, 0x01, 0x01, 0x7f, 0x7f, 0x01, 0x01, 0x00, # 84=T
    0x00, 0x3f, 0x7f, 0x40, 0x40, 0x7f, 0x3f, 0x00, # 85=U
    0x00, 0x1f, 0x3f, 0x60, 0x60, 0x3f, 0x1f, 0x00, # 86=V
    0x00, 0x7f, 0x7f, 0x30, 0x18, 0x30, 0x7f, 0x7f, # 87=W
    0x00, 0x63, 0x77, 0x1c, 0x1c, 0x77, 0x63, 0x00, # 88=X
    0x00, 0x07, 0x0f, 0x78, 0x78, 0x0f, 0x07, 0x00, # 89=Y
    0x00, 0x61, 0x71, 0x59, 0x4d, 0x47, 0x43, 0x00, # 90=Z
    0x00, 0x00, 0x7f, 0x7f, 0x41, 0x41, 0x00, 0x00, # 91=[
    0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x40, # 92='\'
    0x00, 0x00, 0x41, 0x41, 0x7f, 0x7f, 0x00, 0x00, # 93=]
    0x00, 0x08, 0x0c, 0x06, 0x06, 0x0c, 0x08, 0x00, # 94=^
    0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, # 95=_
    0x00, 0x00, 0x01, 0x03, 0x06, 0x04, 0x00, 0x00, # 96=`
    0x00, 0x20, 0x74, 0x54, 0x54, 0x7c, 0x78, 0x00, # 97=a
    0x00, 0x7f, 0x7f, 0x44, 0x44, 0x7c, 0x38, 0x00, # 98=b
    0x00, 0x38, 0x7c, 0x44, 0x44, 0x6c, 0x28, 0x00, # 99=c
    0x00, 0x38, 0x7c, 0x44, 0x44, 0x7f, 0x7f, 0x00, # 100=d
    0x00, 0x38, 0x7c, 0x54, 0x54, 0x5c, 0x58, 0x00, # 101=e
    0x00, 0x08, 0x7e, 0x7f, 0x09, 0x03, 0x02, 0x00, # 102=f
    0x00, 0x98, 0xbc, 0xa4, 0xa4, 0xfc, 0x7c, 0x00, # 103=g
    0x00, 0x7f, 0x7f, 0x04, 0x04, 0x7c, 0x78, 0x00, # 104=h
    0x00, 0x00, 0x00, 0x7d, 0x7d, 0x00, 0x00, 0x00, # 105=i
    0x00, 0x40, 0xc0, 0x80, 0x80, 0xfd, 0x7d, 0x00, # 106=j
    0x00, 0x7f, 0x7f, 0x30, 0x38, 0x6c, 0x44, 0x00, # 107=k
    0x00, 0x00, 0x41, 0x7f, 0x7f, 0x40, 0x00, 0x00, # 108=l
    0x00, 0x7c, 0x7c, 0x18, 0x30, 0x18, 0x7c, 0x7c, # 109=m
    0x00, 0x7c, 0x7c, 0x04, 0x04, 0x7c, 0x78, 0x00, # 110=n
    0x00, 0x38, 0x7c, 0x44, 0x44, 0x7c, 0x38, 0x00, # 111=o
    0x00, 0xfc, 0xfc, 0x24, 0x24, 0x3c, 0x18, 0x00, # 112=p
    0x00, 0x18, 0x3c, 0x24, 0x24, 0xfc, 0xfc, 0x00, # 113=q
    0x00, 0x7c, 0x7c, 0x04, 0x04, 0x0c, 0x08, 0x00, # 114=r
    0x00, 0x48, 0x5c, 0x54, 0x54, 0x74, 0x20, 0x00, # 115=s
    0x04, 0x04, 0x3f, 0x7f, 0x44, 0x64, 0x20, 0x00, # 116=t
    0x00, 0x3c, 0x7c, 0x40, 0x40, 0x7c, 0x3c, 0x00, # 117=u
    0x00, 0x1c, 0x3c, 0x60, 0x60, 0x3c, 0x1c, 0x00, # 118=v
    0x00, 0x1c, 0x7c, 0x30, 0x18, 0x30, 0x7c, 0x1c, # 119=w
    0x00, 0x44, 0x6c, 0x38, 0x38, 0x6c, 0x44, 0x00, # 120=x
    0x00, 0x9c, 0xbc, 0xa0, 0xa0, 0xfc, 0x7c, 0x00, # 121=y
    0x00, 0x44, 0x64, 0x74, 0x5c, 0x4c, 0x44, 0x00, # 122=z
    0x00, 0x08, 0x08, 0x3e, 0x77, 0x41, 0x41, 0x00, # 123={
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, # 124=|
    0x00, 0x41, 0x41, 0x77, 0x3e, 0x08, 0x08, 0x00, # 125=}
    0x00, 0x02, 0x03, 0x01, 0x03, 0x02, 0x03, 0x01, # 126=~
    0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, # 127
]




class Tetris:
	def __init__(self, oled, buttons):
		self.oled = oled
		self.buttons = buttons
		
		self.oled.fill(0)
		self.oled.show()

		self.game_step_time = 500

		# nr of unique rotations per piece
		self.piece_rotations = [1, 2, 2, 2, 4, 4, 4]

		# Piece data: [piece_nr * 32 + rot_nr * 8 + brick_nr * 2 + j]
		# with rot_nr between 0 and 4
		# with the brick number between 0 and 4
		# and j == 0 for X coord, j == 1 for Y coord
		self.piece_data = [
			# square block
			0, 0, -1, 0, -1, -1, 0, -1, 
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,

			# line block
			0, 0, -2, 0, -1, 0, 1, 0,
			0, 0, 0, 1, 0, -1, 0, -2,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,

			# S-block
			0, 0, -1, -1, 0, -1, 1, 0, 
			0, 0, 0, 1, 1, 0, 1, -1, 
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,

			# Z-block
			0, 0, -1, 0, 0, -1, 1, -1, 
			0, 0, 1, 1, 1, 0, 0, -1, 
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,

			# L-block
			0, 0, -1, 0, -1, -1, 1, 0, 
			0, 0, 0, 1, 0, -1, 1, -1, 
			0, 0, -1, 0, 1, 0, 1, 1, 
			0, 0, -1, 1, 0, 1, 0, -1, 

			# J-block
			0, 0, -1, 0, 1, 0, 1, -1, 
			0, 0, 0, 1, 0, -1, 1, 1, 
			0, 0, -1, 1, -1, 0, 1, 0, 
			0, 0, 0, 1, 0, -1, -1, -1, 

			# T-block
			0, 0, -1, 0, 0, -1, 1, 0,  
			0, 0, 0, 1, 0, -1, 1, 0, 
			0, 0, -1, 0, 0, 1, 1, 0, 
			0, 0, -1, 0, 0, 1, 0, -1
		]

		self.oled.fill(1)
		self.draw_field_lines()
		self.oled.show()

		self.buttons.up.irq(self.btn_right, trigger=Pin.IRQ_RISING)
		self.buttons.down.irq(self.btn_left, trigger=Pin.IRQ_RISING)
		self.buttons.left.irq(self.btn_up, trigger=Pin.IRQ_RISING)
		self.buttons.right.irq(self.btn_down, trigger=Pin.IRQ_RISING)
		self.buttons.middle.irq(self.btn_a, trigger=Pin.IRQ_RISING)

	def tetris_loop(self):
		while True:
			self.game_init()
			self.draw_updated_score()

			while not self.game_over:
				self.draw()
				self.game_update()

			while self.game_over:
				self.draw_game_over()
				pass

	def game_init(self):
		self.game_over = False
		self.buttons.middle.irq(self.btn_a, trigger=Pin.IRQ_RISING)
		# Init game state
		self.spawn_new_piece()
		self.field = [[0 for i in range(FIELD_WIDTH)] for j in range(FIELD_HEIGHT)]
		self.last_update = time.ticks_ms()
		self.score = 0


	def spawn_new_piece(self):
		self.piece_type = urandom.getrandbits(8) % 7
		self.piece_x = 4
		self.piece_y = 0
		self.piece_rot = 0


	def game_update(self):
		cur_ticks = time.ticks_ms()
		if cur_ticks - self.last_update > self.game_step_time:
			# Move piece down
			self.lower_piece()
			self.last_update = cur_ticks

	def rotate_piece(self):
		self.piece_rot += 1
		if self.piece_rot >= self.piece_rotations[self.piece_type]:
			self.piece_rot = 0

	def is_side_collision(self):
		for square in range(4):
			x_off = self.piece_data[self.piece_type * 32 + self.piece_rot * 8 + square * 2 + 0]
			y_off = self.piece_data[self.piece_type * 32 + self.piece_rot * 8 + square * 2 + 1]

			abs_x = self.piece_x + x_off
			abs_y = self.piece_y + y_off

			# collision with walls
			if abs_x < 0 or abs_x >= FIELD_WIDTH:
				return True

			# collision with field blocks
			if self.field[abs_y][abs_x]:
				return True

		return False


	def move_left(self):
		self.piece_x -= 1

		# check collision with walls
		if self.is_side_collision():
			self.piece_x += 1

	def move_right(self):
		self.piece_x += 1

		# check collision with walls
		if self.is_side_collision():
			self.piece_x -= 1


	def lower_piece(self):
		self.piece_y += 1

		# check for collisions
		collision = False
		for square in range(4):
			x_off = self.piece_data[self.piece_type * 32 + self.piece_rot * 8 + square * 2 + 0]
			y_off = self.piece_data[self.piece_type * 32 + self.piece_rot * 8 + square * 2 + 1]

			abs_x = self.piece_x + x_off
			abs_y = self.piece_y + y_off

			try:
				if abs_y >= FIELD_HEIGHT or self.field[abs_y][abs_x]:
					collision = True
					break
			except:
				print("Out-of-bounds?!")
				pass

		if collision:
			# if at the top, game over
			if self.piece_y == 1:
				self.game_over = True
				# time.sleep(5)
				# self.game_init()
				self.buttons.middle.irq(self.btn_select, trigger=Pin.IRQ_RISING)
				return

			# add to field
			self.piece_y -= 1
			for square in range(4):
				x_off = self.piece_data[self.piece_type * 32 + self.piece_rot * 8 + square * 2 + 0]
				y_off = self.piece_data[self.piece_type * 32 + self.piece_rot * 8 + square * 2 + 1]

				abs_x = self.piece_x + x_off
				abs_y = self.piece_y + y_off

				self.field[abs_y][abs_x] = True

			# check for line clears
			self.check_for_filled_lines()

			# Spawn new piece
			self.spawn_new_piece()


	def check_for_filled_lines(self):
		for row in range(FIELD_HEIGHT):
			fill_count = 0
			for column in range(FIELD_WIDTH):
				fill_count += self.field[row][column]
			if fill_count == FIELD_WIDTH:
				# Increase score
				self.score += 1
				self.draw_updated_score()

				# Remove line
				for row2 in range(row, 0, -1):
					for column2 in range(FIELD_WIDTH):
						self.field[row2][column2] = self.field[row2-1][column2]

	def draw(self):
		self.draw_field()
		self.draw_current_piece()
		self.oled.show()

	def draw_updated_score(self):
		self.oled.rect(0, 0, 8, OLED_HEIGHT, 1, True)
		print(f"Score:{self.score:d}")
		self.rotated_text(f"Score:{self.score:d}", 0, 0)
		self.oled.show()

	def draw_game_over(self):
		self.oled.fill(1)
		self.rotated_text(f"Score:{self.score:d}", 0, 0)
		self.rotated_text("GAME", 20, 20)
		self.rotated_text("OVER", 20, 30)
		self.rotated_text(":(", 30, 40)
		self.oled.show()

	def draw_field_lines(self):
		# self.oled.rect(10, 10, 100, 200, 1, True)
		#for column in range(10):
		#	self.oled.drawLine(10 + 10 * column, 10, 10 + 10 * column, 210, 0x000000)
		#for row in range(20):
		#	self.oled.drawLine(10, 10 + 10 * row, 110, 10 + 10 * row, 0x000000)
		pass

	def draw_field(self):
		for column in range(FIELD_WIDTH):
			for row in range(FIELD_HEIGHT):
				self.draw_square(row, column, self.field[row][column])
		self.draw_field_lines()

	def draw_current_piece(self):
		for square in range(4):
			# [piece_nr * 32 + rot_nr * 8 + brick_nr * 2 + j]
			x_off = self.piece_data[self.piece_type * 32 + self.piece_rot * 8 + square * 2 + 0]
			y_off = self.piece_data[self.piece_type * 32 + self.piece_rot * 8 + square * 2 + 1]

			abs_x = self.piece_x + x_off
			abs_y = self.piece_y + y_off

			self.draw_square(abs_y, abs_x, True)


	def draw_square(self, row, column, filled=True):
		if row < 0 or column < 0 or row >= FIELD_HEIGHT or column >= FIELD_WIDTH:
			return
		self.oled.rect(
			OLED_WIDTH - BLOCK_SIZE * (FIELD_HEIGHT-row),
			OLED_HEIGHT - (BLOCK_SIZE * column) - 8, 
			BLOCK_SIZE,
			BLOCK_SIZE,
			1 if filled else 0, not filled
		)


	def btn_a(self, pressed):
		if pressed:
			print("Rotating piece")
			self.rotate_piece()

	def btn_b(self, pressed):
		if pressed:
			print("Rotating piece")
			self.rotate_piece()

	def btn_left(self, pressed):
		if pressed:
			print("Moving piece left")
			self.move_left()

	def btn_right(self, pressed):
		if pressed:
			print("Moving piece right")
			self.move_right()

	def btn_down(self, pressed):
		if pressed:
			print("Moving piece down")
			self.lower_piece()

	def btn_up(self, pressed):
		if pressed:
			print("Rotating piece")
			self.rotate_piece()

	def btn_start(self, pressed):
		if pressed:
			print("Returning to homescreen")
			# system.home()

	def btn_select(self, pressed):
		if pressed:
			print("Resetting game")
			self.game_init()	

	# Based on https://github.com/micropython/micropython/blob/668a7bd28a49980b239fd7666684885382526988/extmod/modframebuf.c#L805
	def rotated_text(self, text, x0, y0, color=0):
		# const uint8_t *chr_data = &font_petme128_8x8[(chr - 32) * 8];
        # // loop over char data
        # for (int j = 0; j < 8; j++, x0++) {
        #     if (0 <= x0 && x0 < self->width) { // clip x
        #         uint vline_data = chr_data[j]; // each byte is a column of 8 pixels, LSB at top
        #         for (int y = y0; vline_data; vline_data >>= 1, y++) { // scan over vertical column
        #             if (vline_data & 1) { // only draw if pixel set
        #                 if (0 <= y && y < self->height) { // clip y
        #                     setpixel(sself.oledelf, x0, y, col);
        #                 }
        #             }
        #         }
        #     }
        # }

		for c in text:
			assert(ord(c) >= 32 and ord(c) <= 127)

			chr_data = lambda i: font_petme128_8x8[(ord(c) - 32) * 8 + i]
			for j in range(8):
				# TODO clip x
				vline_data = chr_data(j)
				y = y0
				while vline_data != 0:
					
					if vline_data & 1:
						# TODO clip y
						self.oled.pixel(y, OLED_HEIGHT - x0, color)

					vline_data = vline_data >> 1
					y += 1
				x0 += 1